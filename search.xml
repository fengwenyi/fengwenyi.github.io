<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[个人网站第四次改版了]]></title>
    <url>%2F2019%2F05%2F12%2F%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99V4%2F</url>
    <content type="text"><![CDATA[我是冯文议，一名JAVA工程师。 从2015年学习做网页开始，一直在折腾自己的个人网站，如今已经折腾了4个版本了。平时也忙着学习JAVA，只能抽空余时间随便写写，所以更新速度稍显缓慢。 写个人网站，可能有以下两个原因： 展示自己。认识一个新朋友，我们自我介绍，那么我该如何用简洁的语言，向他介绍我自己呢，出于这样的想法，诞生了个人网站，我可以不断打磨介绍自己的语言，词语，以便对面可以快速，也更准确的了解自己。 总结。我想把我过去一年学到的东西总结一下，然后分享给大家，也想帮助那些正在迷路上的朋友，哪怕一丁点，也是很开心的。 由于自己毕竟是业余的，加之，菜是原罪的缘故，会有问题，或者不合理的地方，如果你发现了，可以通过留言或者邮箱的方式，告诉给我，我会寻找解决办法，以便能及时修复问题。 下面聊一聊，第四次版本，具体都有哪些内容。 首页首页该有的都有，但绝不多余，只求简洁。我就在这里就让你感受到我欢迎朋友的热情。 你可以点击播放背景音乐，这样可以一边听音乐，一边浏览。 认识我 来一段自我介绍吧 开源2018年开始，我自己写了一个开源框架，如今又增加了两个，不知道你是否感兴趣呢？ 爱情 一首小诗，爱情是生活不可获取的重要部分，祝天下有情人终成眷属。 博客 个人网站只是一个聚合展示，更多内容，还是要去看博客的，你说，对吗？你可以选取你方便的，关注一波。 留言 来都来了，总得留下点什么吧 遇到什么问题，遇到什么事，都是可以在这里说的，留言不公开。 移动端这个版本，依然做了兼容移动设备 这是我的华为 P20 谷歌浏览器的效果截图 再也没有多余的东西，如此简洁。 夜间模式大家都是夜猫子，我也是，夜间学习，自然是要保护好眼睛的 考虑到这一点，因此也提供了夜间模式，时间段是，晚上8点，到早点8点 网站说了这么多，你是不是等不及了： 1www.fengwenyi.com 最后，感谢大家一直以来的支持]]></content>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch实战篇——Spring Boot整合ElasticSearch]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot%E7%BB%93%E5%90%88Elasticsearch%EF%BC%8C%E6%89%8B%E6%9C%BA%E6%90%9C%E7%B4%A2%E5%B0%8F%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[当前Spring Boot很是流行，包括我自己，也是在用Spring Boot集成其他框架进行项目开发，所以这一节，我们一起来探讨Spring Boot整合ElasticSearch的问题。 本文主要讲以下内容： 第一部分，通读文档 第二部分，Spring Boot整合ElasticSearch 第三部分，基本的CRUD操作 第四部分，搜索 第五部分，例子 还没有学过Elasticsearch的朋友，可以先学这个系列的第一节（这个系列共三节），如果你有不明白或者不正确的地方，可以给我评论、留言或者私信。 第一步，通读文档Spring Data Elasticsearch 官方文档，这是当前最新的文档。 关于repository文档一开始就介绍 CrudRepository ，比如，继承 Repository，其他比如 JpaRepository、MongoRepository是继承CrudRepository。也对其中的方法做了简单说明，我们一起来看一下： 1234567891011121314151617181920212223public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123;// Saves the given entity. &lt;S extends T&gt; S save(S entity); // Returns the entity identified by the given ID. Optional&lt;T&gt; findById(ID primaryKey); // Returns all entities. Iterable&lt;T&gt; findAll(); // Returns the number of entities. long count(); // Deletes the given entity. void delete(T entity); // Indicates whether an entity with the given ID exists. boolean existsById(ID primaryKey); // … more functionality omitted.&#125; 好了，下面我们看一下今天的主角 ElasticsearchRepository 他是怎样的吧。 这说明什么？ 用法和JPA一样； 再这他除了有CRUD的基本功能之外，还有分页和排序。 清楚了这之后，是不是应该考虑该如何使用了呢？ 如何用？没错，接下来，开始说如何用，也写了很多示例代码。相对来说，还是比较简单，这里就贴一下代码就行了吧。 1234567891011121314151617interface PersonRepository extends Repository&lt;User, Long&gt; &#123; List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname); // Enables the distinct flag for the query List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname); List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname); // Enabling ignoring case for an individual property List&lt;Person&gt; findByLastnameIgnoreCase(String lastname); // Enabling ignoring case for all suitable properties List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname); // Enabling static ORDER BY for a query List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname); List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);&#125; 是不是这样，就可以正常使用了呢？ 问题当然可以，但是如果错了问题怎么办呢，官网写了一个常见的问题，比如包扫描问题，没有你要的方法。 12345678910111213141516171819202122232425262728interface HumanRepository &#123; void someHumanMethod(User user);&#125;class HumanRepositoryImpl implements HumanRepository &#123; public void someHumanMethod(User user) &#123; // Your custom implementation &#125;&#125;interface ContactRepository &#123; void someContactMethod(User user); User anotherContactMethod(User user);&#125;class ContactRepositoryImpl implements ContactRepository &#123; public void someContactMethod(User user) &#123; // Your custom implementation &#125; public User anotherContactMethod(User user) &#123; // Your custom implementation &#125;&#125; 你也可以自己写接口，并且去实现它。 说完理论，作为我，应该在实际的代码中如何运用呢？ 示例官方也提供了很多示例代码，我们一起来看看。 12345678910111213@Controllerclass PersonController &#123; @Autowired PersonRepository repository; @RequestMapping(value = "/persons", method = RequestMethod.GET) HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable, PagedResourcesAssembler assembler) &#123; Page&lt;Person&gt; persons = repository.findAll(pageable); return new ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK); &#125;&#125; 这段代码相对来说还是十分经典的，我相信很多人都看到别人的代码，可能都会问，它为什么会这么用呢，答案或许就在这里吧。 当然，这是以前的代码，或许现在用不一定合适。 高级搜索终于到高潮了！ 学完我的第一节，你应该已经发现了，Elasticsearch搜索是一件十分复杂的事，为了用好它，我们不得不学好它。一起加油。 到这里，官方文档我们算是过了一遍了，大致明白了，他要告诉我们什么。其实，文档还有很多内容，可能你遇到的问题都能在里面找到答案。 最后，我们继续看一下官网写的一段处理得十分优秀的一段代码吧： 1234567891011121314SearchQuery searchQuery = new NativeSearchQueryBuilder() .withQuery(matchAllQuery()) .withIndices(INDEX_NAME) .withTypes(TYPE_NAME) .withFields("message") .withPageable(PageRequest.of(0, 10)) .build();CloseableIterator&lt;SampleEntity&gt; stream = elasticsearchTemplate.stream(searchQuery, SampleEntity.class);List&lt;SampleEntity&gt; sampleEntities = new ArrayList&lt;&gt;();while (stream.hasNext()) &#123; sampleEntities.add(stream.next());&#125; 第二部分，Spring Boot整合ElasticSearch添加依赖1implementation 'org.springframework.boot:spring-boot-starter-data-elasticsearch' 添加配置12345spring: data: elasticsearch: cluster-nodes: localhost:9300 cluster-name: es-wyf 这样就完成了整合，接下来我们用两种方式操作。 Model我们先写一个的实体类，借助这个实体类呢来完成基础的CRUD功能。 1234567891011121314151617@Data@Accessors(chain = true)@Document(indexName = "blog", type = "java")public class BlogModel implements Serializable &#123; private static final long serialVersionUID = 6320548148250372657L; @Id private String id; private String title; //@Field(type = FieldType.Date, format = DateFormat.basic_date) @DateTimeFormat(pattern = "yyyy-MM-dd") @JsonFormat(pattern = "yyyy-MM-dd", timezone = "GMT+8") private Date time;&#125; 注意id字段是必须的，可以不写注解@Id。 BlogRepository12public interface BlogRepository extends ElasticsearchRepository&lt;BlogModel, String&gt; &#123;&#125; 第三部分，CRUD基础操作的代码，都是在 BlogController 里面写。 123456@RestController@RequestMapping("/blog")public class BlogController &#123; @Autowired private BlogRepository blogRepository;&#125; 添加12345@PostMapping("/add")public Result add(@RequestBody BlogModel blogModel) &#123; blogRepository.save(blogModel); return Result.success();&#125; 我们添加一条数据，标题是：Elasticsearch实战篇：Spring Boot整合ElasticSearch，时间是：2019-03-06。我们来测试，看一下成不成功。 POST http://localhost:8080/blog/add 1234&#123; "title":"Elasticsearch实战篇：Spring Boot整合ElasticSearch", "time":"2019-05-06"&#125; 得到响应： 1234&#123; "code": 0, "msg": "Success"&#125; 嘿，成功了。那接下来，我们一下查询方法测试一下。 查询 根据ID查询 1234567891011@GetMapping("/get/&#123;id&#125;")public Result getById(@PathVariable String id) &#123; if (StringUtils.isEmpty(id)) return Result.error(); Optional&lt;BlogModel&gt; blogModelOptional = blogRepository.findById(id); if (blogModelOptional.isPresent()) &#123; BlogModel blogModel = blogModelOptional.get(); return Result.success(blogModel); &#125; return Result.error();&#125; 测试一下： ok，没问题。 查询所有 1234567@GetMapping("/get")public Result getAll() &#123; Iterable&lt;BlogModel&gt; iterable = blogRepository.findAll(); List&lt;BlogModel&gt; list = new ArrayList&lt;&gt;(); iterable.forEach(list::add); return Result.success(list);&#125; 测试一下： GET http://localhost:8080/blog/get 结果： 123456789101112131415161718192021222324&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "fFXTTmkBTzBv3AXCweFS", "title": "Elasticsearch实战篇：Spring Boot整合ElasticSearch", "time": "2019-05-06" &#125; ]&#125;``` #### 根据ID修改```java@PostMapping("/update")public Result updateById(@RequestBody BlogModel blogModel) &#123; String id = blogModel.getId(); if (StringUtils.isEmpty(id)) return Result.error(); blogRepository.save(blogModel); return Result.success();&#125; 测试： POST http://localhost:8080/blog/update 12345&#123; "id":"fFXTTmkBTzBv3AXCweFS", "title":"Elasticsearch入门篇", "time":"2019-05-01"&#125; 响应： 1234&#123; "code": 0, "msg": "Success"&#125; 查询一下： ok，成功！ 删除 根据ID删除 1234567@DeleteMapping("/delete/&#123;id&#125;")public Result deleteById(@PathVariable String id) &#123; if (StringUtils.isEmpty(id)) return Result.error(); blogRepository.deleteById(id); return Result.success();&#125; 测试： DELETE http://localhost:8080/blog/delete/fFXTTmkBTzBv3AXCweFS 响应： 1234&#123; "code": 0, "msg": "Success"&#125; 我们再查一下： 删除所有数据 12345@DeleteMapping("/delete")public Result deleteById() &#123; blogRepository.deleteAll(); return Result.success();&#125; 第四部分，搜索构造数据为了方便测试，我们先构造数据 Repository查询操作搜索标题中的关键字 BlogRepository 1List&lt;BlogModel&gt; findByTitleLike(String keyword); BlogController 123456@GetMapping("/rep/search/title")public Result repSearchTitle(String keyword) &#123; if (StringUtils.isEmpty(keyword)) return Result.error(); return Result.success(blogRepository.findByTitleLike(keyword));&#125; 我们来测试一下。 POST http://localhost:8080/blog/rep/search/title?keyword=java 结果：12345678910111213141516171819202122232425262728293031&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "f1XrTmkBTzBv3AXCeeFA", "title": "java实战", "time": "2018-03-01" &#125;, &#123; "id": "fVXrTmkBTzBv3AXCHuGH", "title": "java入门", "time": "2018-01-01" &#125;, &#123; "id": "flXrTmkBTzBv3AXCUOHj", "title": "java基础", "time": "2018-02-01" &#125;, &#123; "id": "gFXrTmkBTzBv3AXCn-Eb", "title": "java web", "time": "2018-04-01" &#125;, &#123; "id": "gVXrTmkBTzBv3AXCzuGh", "title": "java ee", "time": "2018-04-10" &#125; ]&#125; 继续搜索： GET http://localhost:8080/blog/rep/search/title?keyword=入门 结果： 123456789101112131415161718192021&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "hFXsTmkBTzBv3AXCtOE6", "title": "Elasticsearch入门", "time": "2019-01-20" &#125;, &#123; "id": "fVXrTmkBTzBv3AXCHuGH", "title": "java入门", "time": "2018-01-01" &#125;, &#123; "id": "glXsTmkBTzBv3AXCBeH_", "title": "php入门", "time": "2018-05-10" &#125; ]&#125; 为了验证，我们再换一个关键字搜索： GET http://localhost:8080/blog/rep/search/title?keyword=java入门 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "fVXrTmkBTzBv3AXCHuGH", "title": "java入门", "time": "2018-01-01" &#125;, &#123; "id": "hFXsTmkBTzBv3AXCtOE6", "title": "Elasticsearch入门", "time": "2019-01-20" &#125;, &#123; "id": "glXsTmkBTzBv3AXCBeH_", "title": "php入门", "time": "2018-05-10" &#125;, &#123; "id": "gFXrTmkBTzBv3AXCn-Eb", "title": "java web", "time": "2018-04-01" &#125;, &#123; "id": "gVXrTmkBTzBv3AXCzuGh", "title": "java ee", "time": "2018-04-10" &#125;, &#123; "id": "f1XrTmkBTzBv3AXCeeFA", "title": "java实战", "time": "2018-03-01" &#125;, &#123; "id": "flXrTmkBTzBv3AXCUOHj", "title": "java基础", "time": "2018-02-01" &#125; ]&#125; 哈哈，有没有觉得很眼熟。 那根据上次的经验，我们正好换一种方式解决这个问题。 12@Query("&#123;\"match_phrase\":&#123;\"title\":\"?0\"&#125;&#125;")List&lt;BlogModel&gt; findByTitleCustom(String keyword); 值得一提的是，官方文档示例代码可能是为了好看，出现问题。 官网文档给的错误示例： 官网示例代码： 官方示例代码 另外，?0 代指变量的意思。 123456@GetMapping("/rep/search/title/custom")public Result repSearchTitleCustom(String keyword) &#123; if (StringUtils.isEmpty(keyword)) return Result.error(); return Result.success(blogRepository.findByTitleCustom(keyword));&#125; 测试一下： ok，没有问题。 ElasticsearchTemplate12345678910111213@Autowiredprivate ElasticsearchTemplate elasticsearchTemplate;@GetMapping("/search/title")public Result searchTitle(String keyword) &#123; if (StringUtils.isEmpty(keyword)) return Result.error(); SearchQuery searchQuery = new NativeSearchQueryBuilder() .withQuery(queryStringQuery(keyword)) .build(); List&lt;BlogModel&gt; list = elasticsearchTemplate.queryForList(searchQuery, BlogModel.class); return Result.success(list);&#125; 测试： POST http://localhost:8080/blog/search/title?keyword=java入门 结果： 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "fVXrTmkBTzBv3AXCHuGH", "title": "java入门", "time": "2018-01-01" &#125;, &#123; "id": "hFXsTmkBTzBv3AXCtOE6", "title": "Elasticsearch入门", "time": "2019-01-20" &#125;, &#123; "id": "glXsTmkBTzBv3AXCBeH_", "title": "php入门", "time": "2018-05-10" &#125;, &#123; "id": "gFXrTmkBTzBv3AXCn-Eb", "title": "java web", "time": "2018-04-01" &#125;, &#123; "id": "gVXrTmkBTzBv3AXCzuGh", "title": "java ee", "time": "2018-04-10" &#125;, &#123; "id": "f1XrTmkBTzBv3AXCeeFA", "title": "java实战", "time": "2018-03-01" &#125;, &#123; "id": "flXrTmkBTzBv3AXCUOHj", "title": "java基础", "time": "2018-02-01" &#125; ]&#125; OK，暂时先到这里，关于搜索，我们后面会专门开一个专题，学习搜索。 第五部分，例子我们写个什么例子，想了很久，那就写一个搜索手机的例子吧！ 界面截图我们先看下最后实现的效果吧 主页效果： 分页效果： 我们搜索 “小米”： 我们搜索 “1999”： 我们搜索 “黑色”： 高级搜索页面： 我们使用高级搜索，搜索：“小米”、“1999”： 高级搜索 “小米”、“1999” 结果： 上面的并且关系生效了吗？我们试一下搜索 “华为”，“1999”： 最后，我们尝试搜索时间段： 看一下，搜索结果吧： 说实话，这个时间搜索结果，我不是很满意，ES 的时间问题，我打算在后面花一些时间去研究下。 搭建项目基于Gradle搭建Spring Boot项目，把我折腾的受不了（如果哪位这方面有经验，可以给我指点指点），这个demo写了很久，那天都跑的好好的，今早上起来，就跑步起来了，一气之下，就改成Maven了。 下面看一下我的依赖和配置 pom.xml 片段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jitpack.io&lt;/id&gt; &lt;url&gt;https://jitpack.io&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加 JavaLib 支持 用于接口返回 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.fengwenyi&lt;/groupId&gt; &lt;artifactId&gt;JavaLib&lt;/artifactId&gt; &lt;version&gt;1.0.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 webflux 支持 用于编写非阻塞接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加 fastjson 的支持 用于处理JSON格式数据 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.56&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 Httpclient 的支持 用于网络请求 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 jsoup 的支持 用于解析网页内容 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.10.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; application.yml 12345678910server: port: 9090spring: data: elasticsearch: cluster-nodes: localhost:9300 cluster-name: es-wyf repositories: enabled: true PhoneModel 123456789101112131415161718192021222324252627282930313233343536373839@Data@Accessors(chain = true)@Document(indexName = "springboot_elasticsearch_example_phone", type = "com.fengwenyi.springbootelasticsearchexamplephone.model.PhoneModel")public class PhoneModel implements Serializable &#123; private static final long serialVersionUID = -5087658155687251393L; /* ID */ @Id private String id; /* 名称 */ private String name; /* 颜色，用英文分号(;)分隔 */ private String colors; /* 卖点，用英文分号(;)分隔 */ private String sellingPoints; /* 价格 */ private String price; /* 产量 */ private Long yield; /* 销售量 */ private Long sale; /* 上市时间 */ //@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8") private Date marketTime; /* 数据抓取时间 */ //@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8") private Date createTime;&#125; PhoneRepository 12public interface PhoneRepository extends ElasticsearchRepository&lt;PhoneModel, String&gt; &#123;&#125; PhoneController 123456789@RestController@RequestMapping(value = "/phone")@CrossOriginpublic class PhoneController &#123; @Autowired private ElasticsearchTemplate elasticsearchTemplate;&#125; 后面接口，都会在这里写。 构造数据我的数据是抓的 “华为” 和 “小米” 官网 首先使用 httpclient 下载html，然后使用 jsoup 进行解析。 以 华为 为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void huawei() throws IOException &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建httpclient实例 HttpGet httpget = new HttpGet("https://consumer.huawei.com/cn/phones/?ic_medium=hwdc&amp;ic_source=corp_header_consumer"); // 创建httpget实例 CloseableHttpResponse response = httpclient.execute(httpget); // 执行get请求 HttpEntity entity=response.getEntity(); // 获取返回实体 //System.out.println("网页内容："+ EntityUtils.toString(entity, "utf-8")); // 指定编码打印网页内容 String content = EntityUtils.toString(entity, "utf-8"); response.close(); // 关闭流和释放系统资源// System.out.println(content); Document document = Jsoup.parse(content); Elements elements = document.select("#content-v3-plp #pagehidedata .plphidedata"); for (Element element : elements) &#123;// System.out.println(element.text()); String jsonStr = element.text(); List&lt;HuaWeiPhoneBean&gt; list = JSON.parseArray(jsonStr, HuaWeiPhoneBean.class); for (HuaWeiPhoneBean bean : list) &#123; String productName = bean.getProductName(); List&lt;ColorModeBean&gt; colorsItemModeList = bean.getColorsItemMode(); StringBuilder colors = new StringBuilder(); for (ColorModeBean colorModeBean : colorsItemModeList) &#123; String colorName = colorModeBean.getColorName(); colors.append(colorName).append(";"); &#125; List&lt;String&gt; sellingPointList = bean.getSellingPoints(); StringBuilder sellingPoints = new StringBuilder(); for (String sellingPoint : sellingPointList) &#123; sellingPoints.append(sellingPoint).append(";"); &#125;// System.out.println("产品名：" + productName);// System.out.println("颜 色：" + color);// System.out.println("买 点：" + sellingPoint);// System.out.println("-----------------------------------"); PhoneModel phoneModel = new PhoneModel() .setName(productName) .setColors(colors.substring(0, colors.length() - 1)) .setSellingPoints(sellingPoints.substring(0, sellingPoints.length() - 1)) .setCreateTime(new Date()); phoneRepository.save(phoneModel); &#125; &#125;&#125; 全文搜索全文搜索来说，还是相对来说，比较简单，直接贴代码吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 全文搜索 * @param keyword 关键字 * @param page 当前页，从0开始 * @param size 每页大小 * @return &#123;@link Result&#125; 接收到的数据格式为json */@GetMapping("/full")public Mono&lt;Result&gt; full(String keyword, int page, int size) &#123; // System.out.println(new Date() + " =&gt; " + keyword); // 校验参数 if (StringUtils.isEmpty(page)) page = 0; // if page is null, page = 0 if (StringUtils.isEmpty(size)) size = 10; // if size is null, size default 10 // 构造分页类 Pageable pageable = PageRequest.of(page, size); // 构造查询 NativeSearchQueryBuilder NativeSearchQueryBuilder searchQueryBuilder = new NativeSearchQueryBuilder() .withPageable(pageable) ; if (!StringUtils.isEmpty(keyword)) &#123; // keyword must not null searchQueryBuilder.withQuery(QueryBuilders.queryStringQuery(keyword)); &#125; /* SearchQuery 这个很关键，这是搜索条件的入口， elasticsearchTemplate 会 使用它 进行搜索 */ SearchQuery searchQuery = searchQueryBuilder.build(); // page search Page&lt;PhoneModel&gt; phoneModelPage = elasticsearchTemplate.queryForPage(searchQuery, PhoneModel.class); // return return Mono.just(Result.success(phoneModelPage));&#125; 官网文档也是这么用的，所以相对来说，这还是很简单的，不过拆词 和 搜索策略 搜索速度 可能在实际使用中要考虑。 高级搜索先看代码，后面我们再来分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 高级搜索，根据字段进行搜索 * @param name 名称 * @param color 颜色 * @param sellingPoint 卖点 * @param price 价格 * @param start 开始时间(格式：yyyy-MM-dd HH:mm:ss) * @param end 结束时间(格式：yyyy-MM-dd HH:mm:ss) * @param page 当前页，从0开始 * @param size 每页大小 * @return &#123;@link Result&#125; */@GetMapping("/_search")public Mono&lt;Result&gt; search(String name, String color, String sellingPoint, String price, String start, String end, int page, int size) &#123; // 校验参数 if (StringUtils.isEmpty(page) || page &lt; 0) page = 0; // if page is null, page = 0 if (StringUtils.isEmpty(size) || size &lt; 0) size = 10; // if size is null, size default 10 // 构造分页对象 Pageable pageable = PageRequest.of(page, size); // BoolQueryBuilder (Elasticsearch Query) BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder(); if (!StringUtils.isEmpty(name)) &#123; boolQueryBuilder.must(QueryBuilders.matchQuery("name", name)); &#125; if (!StringUtils.isEmpty(color)) &#123; boolQueryBuilder.must(QueryBuilders.matchQuery("colors", color)); &#125; if (!StringUtils.isEmpty(color)) &#123; boolQueryBuilder.must(QueryBuilders.matchQuery("sellingPoints", sellingPoint)); &#125; if (!StringUtils.isEmpty(price)) &#123; boolQueryBuilder.must(QueryBuilders.matchQuery("price", price)); &#125; if (!StringUtils.isEmpty(start)) &#123; Date startTime = null; try &#123; startTime = DateTimeUtil.stringToDate(start, DateTimeFormat.yyyy_MM_dd_HH_mm_ss); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; boolQueryBuilder.must(QueryBuilders.rangeQuery("createTime").gt(startTime.getTime())); &#125; if (!StringUtils.isEmpty(end)) &#123; Date endTime = null; try &#123; endTime = DateTimeUtil.stringToDate(end, DateTimeFormat.yyyy_MM_dd_HH_mm_ss); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; boolQueryBuilder.must(QueryBuilders.rangeQuery("createTime").lt(endTime.getTime())); &#125; // BoolQueryBuilder (Spring Query) SearchQuery searchQuery = new NativeSearchQueryBuilder() .withPageable(pageable) .withQuery(boolQueryBuilder) .build() ; // page search Page&lt;PhoneModel&gt; phoneModelPage = elasticsearchTemplate.queryForPage(searchQuery, PhoneModel.class); // return return Mono.just(Result.success(phoneModelPage));&#125; 不管spring如何封装，查询方式都一样，如下图： 好吧，我们怀着这样的心态去看下源码。 1org.springframework.data.elasticsearch.core.query.SearchQuery 这个是我们搜索需要用到对象 1234public NativeSearchQueryBuilder withQuery(QueryBuilder queryBuilder) &#123; this.queryBuilder = queryBuilder; return this;&#125; OK，根据源码，我们需要构造这个 QueryBuilder，那么问题来了，这个是个什么东西，我们要如何构造，继续看： 1org.elasticsearch.index.query.QueryBuilder 注意包名。 啥，怎么又跑到 elasticsearch。 你想啊，你写的东西，会让别人直接操作吗？ 答案是不会的，我们只会提供API，所有，不管Spring如何封装，也只会通过API去调用。 好吧，今天先到这里，下一个专题，我们再讨论关于搜索问题。 链接 ElasticSearch入门 Elastic官网 ElasticSearch ElasticSearch Docs ElasticSearch Head 搜索软件Elastic上市：市值近50亿美元 是开源项目商业化范本 ElasticSearch 学习系列 Elasticsearch入门篇——基础知识 Elasticsearch实战篇——Spring Boot整合ElasticSearch Elasticsearch专题篇——搜索 代码Spring Boot整合Elasticsearch Spring Boot结合Elasticsearch，实现手机信息搜索小例子 演示视频 如果无法播放，请点击这里]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch实战篇——Spring Boot整合ElasticSearch]]></title>
    <url>%2F2019%2F03%2F11%2FElasticsearch%E5%AE%9E%E6%88%98%E7%AF%87%2F</url>
    <content type="text"><![CDATA[当前Spring Boot很是流行，包括我自己，也是在用Spring Boot集成其他框架进行项目开发，所以这一节，我们一起来探讨Spring Boot整合ElasticSearch的问题。 步骤如下： 第一步，通读文档。 第二步，用三种方式实现基本CRUD操作。 第三步，分析实战中可能用到的查询。 第四步，搜索专题。 还没有学过Elasticsearch的朋友，可以先学这个系列的第一节（这个系列共三节），如果你有不明白或者不正确的地方，可以给我评论、留言或者私信。 第一步，通读文档Spring Data Elasticsearch 官方文档，这是当前最新的文档。 关于repository文档一开始就介绍 CrudRepository ，比如，继承 Repository，其他比如 JpaRepository、MongoRepository是继承CrudRepository。也对其中的方法做了简单说明，我们一起来看一下： 1234567891011121314151617181920212223public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123;// Saves the given entity. &lt;S extends T&gt; S save(S entity); // Returns the entity identified by the given ID. Optional&lt;T&gt; findById(ID primaryKey); // Returns all entities. Iterable&lt;T&gt; findAll(); // Returns the number of entities. long count(); // Deletes the given entity. void delete(T entity); // Indicates whether an entity with the given ID exists. boolean existsById(ID primaryKey); // … more functionality omitted.&#125; 好了，下面我们看一下今天的主角 ElasticsearchRepository 他是怎样的吧。 这说明什么？ 用法和JPA一样； 再这他除了有CRUD的基本功能之外，还有分页和排序。 清楚了这之后，是不是应该考虑该如何使用了呢？ 如何用？没错，接下来，开始说如何用，也写了很多示例代码。相对来说，还是比较简单，这里就贴一下代码就行了吧。 1234567891011121314151617interface PersonRepository extends Repository&lt;User, Long&gt; &#123; List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname); // Enables the distinct flag for the query List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname); List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname); // Enabling ignoring case for an individual property List&lt;Person&gt; findByLastnameIgnoreCase(String lastname); // Enabling ignoring case for all suitable properties List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname); // Enabling static ORDER BY for a query List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname); List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);&#125; 是不是这样，就可以正常使用了呢？ 问题当然可以，但是如果错了问题怎么办呢，官网写了一个常见的问题，比如包扫描问题，没有你要的方法。 12345678910111213141516171819202122232425262728interface HumanRepository &#123; void someHumanMethod(User user);&#125;class HumanRepositoryImpl implements HumanRepository &#123; public void someHumanMethod(User user) &#123; // Your custom implementation &#125;&#125;interface ContactRepository &#123; void someContactMethod(User user); User anotherContactMethod(User user);&#125;class ContactRepositoryImpl implements ContactRepository &#123; public void someContactMethod(User user) &#123; // Your custom implementation &#125; public User anotherContactMethod(User user) &#123; // Your custom implementation &#125;&#125; 你也可以自己写接口，并且去实现它。 说完理论，作为我，应该在实际的代码中如何运用呢？ 示例官方也提供了很多示例代码，我们一起来看看。 12345678910111213@Controllerclass PersonController &#123; @Autowired PersonRepository repository; @RequestMapping(value = "/persons", method = RequestMethod.GET) HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable, PagedResourcesAssembler assembler) &#123; Page&lt;Person&gt; persons = repository.findAll(pageable); return new ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK); &#125;&#125; 这段代码相对来说还是十分经典的，我相信很多人都看到别人的代码，可能都会问，它为什么会这么用呢，答案或许就在这里吧。 当然，这是以前的代码，或许现在用不一定合适。 高级搜索终于到高潮了！ 学完我的第一节，你应该已经发现了，Elasticsearch搜索是一件十分复杂的事，为了用好它，我们不得不学好它。一起加油。 到这里，官方文档我们算是过了一遍了，大致明白了，他要告诉我们什么。其实，文档还有很多内容，可能你遇到的问题都能在里面找到答案。 最后，我们继续看一下官网写的一段处理得十分优秀的一段代码吧： 1234567891011121314SearchQuery searchQuery = new NativeSearchQueryBuilder() .withQuery(matchAllQuery()) .withIndices(INDEX_NAME) .withTypes(TYPE_NAME) .withFields("message") .withPageable(PageRequest.of(0, 10)) .build();CloseableIterator&lt;SampleEntity&gt; stream = elasticsearchTemplate.stream(searchQuery, SampleEntity.class);List&lt;SampleEntity&gt; sampleEntities = new ArrayList&lt;&gt;();while (stream.hasNext()) &#123; sampleEntities.add(stream.next());&#125; Spring Boot整合ElasticSearch添加依赖1implementation 'org.springframework.boot:spring-boot-starter-data-elasticsearch' 添加配置12345spring: data: elasticsearch: cluster-nodes: localhost:9300 cluster-name: es-wyf 这样就完成了整合，接下来我们用两种方式操作。 Model我们先写一个的实体类，借助这个实体类呢来完成基础的CRUD功能。 1234567891011121314151617@Data@Accessors(chain = true)@Document(indexName = "blog", type = "java")public class BlogModel implements Serializable &#123; private static final long serialVersionUID = 6320548148250372657L; @Id private String id; private String title; //@Field(type = FieldType.Date, format = DateFormat.basic_date) @DateTimeFormat(pattern = "yyyy-MM-dd") @JsonFormat(pattern = "yyyy-MM-dd", timezone = "GMT+8") private Date time;&#125; 注意id字段是必须的，可以不写注解@Id。 RepositoryBlogRepository12public interface BlogRepository extends ElasticsearchRepository&lt;BlogModel, String&gt; &#123;&#125; 基础操作基础操作的代码，都是在 BlogController 里面写。 123456@RestController@RequestMapping("/blog")public class BlogController &#123; @Autowired private BlogRepository blogRepository;&#125; 添加 12345@PostMapping("/add")public Result add(@RequestBody BlogModel blogModel) &#123; blogRepository.save(blogModel); return Result.success();&#125; 我们添加一条数据，标题是：Elasticsearch实战篇：Spring Boot整合ElasticSearch，时间是：2019-03-06。我们来测试，看一下成不成功。 POST http://localhost:8080/blog/add 1234&#123; "title":"Elasticsearch实战篇：Spring Boot整合ElasticSearch", "time":"2019-05-06"&#125; 得到响应： 1234&#123; "code": 0, "msg": "Success"&#125; 嘿，成功了。那接下来，我们一下查询方法测试一下。 查询 根据ID查询 1234567891011@GetMapping("/get/&#123;id&#125;")public Result getById(@PathVariable String id) &#123; if (StringUtils.isEmpty(id)) return Result.error(); Optional&lt;BlogModel&gt; blogModelOptional = blogRepository.findById(id); if (blogModelOptional.isPresent()) &#123; BlogModel blogModel = blogModelOptional.get(); return Result.success(blogModel); &#125; return Result.error();&#125; 测试一下： ok，没问题。 查询所有 1234567@GetMapping("/get")public Result getAll() &#123; Iterable&lt;BlogModel&gt; iterable = blogRepository.findAll(); List&lt;BlogModel&gt; list = new ArrayList&lt;&gt;(); iterable.forEach(list::add); return Result.success(list);&#125; 测试一下： GET http://localhost:8080/blog/get 结果： 123456789101112131415161718192021222324&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "fFXTTmkBTzBv3AXCweFS", "title": "Elasticsearch实战篇：Spring Boot整合ElasticSearch", "time": "2019-05-06" &#125; ]&#125;``` **根据ID修改**```java@PostMapping("/update")public Result updateById(@RequestBody BlogModel blogModel) &#123; String id = blogModel.getId(); if (StringUtils.isEmpty(id)) return Result.error(); blogRepository.save(blogModel); return Result.success();&#125; 测试： POST http://localhost:8080/blog/update 12345&#123; "id":"fFXTTmkBTzBv3AXCweFS", "title":"Elasticsearch入门篇", "time":"2019-05-01"&#125; 响应： 1234&#123; "code": 0, "msg": "Success"&#125; 查询一下： ok，成功！ 删除 根据ID删除 1234567@DeleteMapping("/delete/&#123;id&#125;")public Result deleteById(@PathVariable String id) &#123; if (StringUtils.isEmpty(id)) return Result.error(); blogRepository.deleteById(id); return Result.success();&#125; 测试： DELETE http://localhost:8080/blog/delete/fFXTTmkBTzBv3AXCweFS 响应： 1234&#123; "code": 0, "msg": "Success"&#125; 我们再查一下： 删除所有数据 12345@DeleteMapping("/delete")public Result deleteById() &#123; blogRepository.deleteAll(); return Result.success();&#125; 构造数据为了方便测试，我们先构造数据 Repository查询操作搜索标题中的关键字 BlogRepository 1List&lt;BlogModel&gt; findByTitleLike(String keyword); BlogController 123456@GetMapping("/rep/search/title")public Result repSearchTitle(String keyword) &#123; if (StringUtils.isEmpty(keyword)) return Result.error(); return Result.success(blogRepository.findByTitleLike(keyword));&#125; 我们来测试一下。 POST http://localhost:8080/blog/rep/search/title?keyword=java 结果：12345678910111213141516171819202122232425262728293031&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "f1XrTmkBTzBv3AXCeeFA", "title": "java实战", "time": "2018-03-01" &#125;, &#123; "id": "fVXrTmkBTzBv3AXCHuGH", "title": "java入门", "time": "2018-01-01" &#125;, &#123; "id": "flXrTmkBTzBv3AXCUOHj", "title": "java基础", "time": "2018-02-01" &#125;, &#123; "id": "gFXrTmkBTzBv3AXCn-Eb", "title": "java web", "time": "2018-04-01" &#125;, &#123; "id": "gVXrTmkBTzBv3AXCzuGh", "title": "java ee", "time": "2018-04-10" &#125; ]&#125; 继续搜索： GET http://localhost:8080/blog/rep/search/title?keyword=入门 结果： 123456789101112131415161718192021&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "hFXsTmkBTzBv3AXCtOE6", "title": "Elasticsearch入门", "time": "2019-01-20" &#125;, &#123; "id": "fVXrTmkBTzBv3AXCHuGH", "title": "java入门", "time": "2018-01-01" &#125;, &#123; "id": "glXsTmkBTzBv3AXCBeH_", "title": "php入门", "time": "2018-05-10" &#125; ]&#125; 为了验证，我们再换一个关键字搜索： GET http://localhost:8080/blog/rep/search/title?keyword=java入门 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "fVXrTmkBTzBv3AXCHuGH", "title": "java入门", "time": "2018-01-01" &#125;, &#123; "id": "hFXsTmkBTzBv3AXCtOE6", "title": "Elasticsearch入门", "time": "2019-01-20" &#125;, &#123; "id": "glXsTmkBTzBv3AXCBeH_", "title": "php入门", "time": "2018-05-10" &#125;, &#123; "id": "gFXrTmkBTzBv3AXCn-Eb", "title": "java web", "time": "2018-04-01" &#125;, &#123; "id": "gVXrTmkBTzBv3AXCzuGh", "title": "java ee", "time": "2018-04-10" &#125;, &#123; "id": "f1XrTmkBTzBv3AXCeeFA", "title": "java实战", "time": "2018-03-01" &#125;, &#123; "id": "flXrTmkBTzBv3AXCUOHj", "title": "java基础", "time": "2018-02-01" &#125; ]&#125; 哈哈，有没有觉得很眼熟。 那根据上次的经验，我们正好换一种方式解决这个问题。 12@Query("&#123;\"match_phrase\":&#123;\"title\":\"?0\"&#125;&#125;")List&lt;BlogModel&gt; findByTitleCustom(String keyword); 值得一提的是，官方文档示例代码可能是为了好看，出现问题。 官网文档给的错误示例： 官网示例代码： 官方示例代码 另外，?0 代指变量的意思。 123456@GetMapping("/rep/search/title/custom")public Result repSearchTitleCustom(String keyword) &#123; if (StringUtils.isEmpty(keyword)) return Result.error(); return Result.success(blogRepository.findByTitleCustom(keyword));&#125; 测试一下： ok，没有问题。 ElasticsearchTemplate12345678910111213@Autowiredprivate ElasticsearchTemplate elasticsearchTemplate;@GetMapping("/search/title")public Result searchTitle(String keyword) &#123; if (StringUtils.isEmpty(keyword)) return Result.error(); SearchQuery searchQuery = new NativeSearchQueryBuilder() .withQuery(queryStringQuery(keyword)) .build(); List&lt;BlogModel&gt; list = elasticsearchTemplate.queryForList(searchQuery, BlogModel.class); return Result.success(list);&#125; 测试： POST http://localhost:8080/blog/search/title?keyword=java入门 结果： 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "code": 0, "msg": "Success", "data": [ &#123; "id": "fVXrTmkBTzBv3AXCHuGH", "title": "java入门", "time": "2018-01-01" &#125;, &#123; "id": "hFXsTmkBTzBv3AXCtOE6", "title": "Elasticsearch入门", "time": "2019-01-20" &#125;, &#123; "id": "glXsTmkBTzBv3AXCBeH_", "title": "php入门", "time": "2018-05-10" &#125;, &#123; "id": "gFXrTmkBTzBv3AXCn-Eb", "title": "java web", "time": "2018-04-01" &#125;, &#123; "id": "gVXrTmkBTzBv3AXCzuGh", "title": "java ee", "time": "2018-04-10" &#125;, &#123; "id": "f1XrTmkBTzBv3AXCeeFA", "title": "java实战", "time": "2018-03-01" &#125;, &#123; "id": "flXrTmkBTzBv3AXCUOHj", "title": "java基础", "time": "2018-02-01" &#125; ]&#125; OK，暂时先到这里，关于搜索，我们后面会专门开一个专题，学习搜索。 Jest搜索中，发现Jest也可以操纵Elasticsearch，目前官方有star数1500+。网址：https://github.com/spring-projects/spring-data-elasticsearch。 另外，看到有人提供了Spring Boot整合的代码，如下： 12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class JestClientService implements Serializable &#123; private static final long serialVersionUID = 1L;JestClient client=null; @Value(“$&#123;jest.elasticsearch.host&#125;”) String host; @Value(“$&#123;jest.elasticsearch.port&#125;”) String port; @Value(“$&#123;jest.elasticsearch.index&#125;”) String indexName;/** * */ public JestClient getClient() &#123; if (this.client==null)&#123;GsonFireBuilder fireBuilder = new GsonFireBuilder(); fireBuilder.enableExposeMethodResult(); GsonBuilder builder = fireBuilder.createGsonBuilder(); builder.excludeFieldsWithoutExposeAnnotation(); final Gson gson = builder.setDateFormat(AbstractJestClient.ELASTIC_SEARCH_DATE_FORMAT).create();System.out.println(“Establishing JEST Connection to Elasticsearch over HTTP: “+”http://”+this.host+”:”+this.port); JestClientFactory factory = new JestClientFactory(); factory.setHttpClientConfig(new HttpClientConfig .Builder(“http://”+this.host+”:”+this.port) .multiThreaded(true) .readTimeout(20000) .gson(gson) .build()); this.client = factory.getObject(); &#125; return this.client; &#125;&#125; 链接 ElasticSearch入门 Elastic官网 ElasticSearch ElasticSearch Docs ElasticSearch Head 搜索软件Elastic上市：市值近50亿美元 是开源项目商业化范本 ElasticSearch 学习系列 Elasticsearch入门篇——基础知识 Elasticsearch实战篇——Spring Boot整合ElasticSearch Elasticsearch专题篇——搜索]]></content>
  </entry>
  <entry>
    <title><![CDATA[My First Blog——Hexo+Github搭建个人网站]]></title>
    <url>%2F2019%2F03%2F02%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[终于用 hexo + github 搭建起自己的个人博客了，我的第一篇博文，就来记录一下搭建过程吧！ 安装Hexo1npm install -g hexo-cli 初始化Project1hexo init [project] 本地运行123cd [project]hexo ghexo s 他会告诉，可以访问：http://localhost:4000 远程仓库这里，说一下，仓库的名称格式很严格，规则为：[your github username].github.io 一定得是这样，否则你就跟我一样，慢慢折腾吧！ 配置修改 _config.yml 1234deploy: type: git repo: [your github project repository git/url address] branch: master 发布到远程仓库1234567git initgit add .git remote add origin [your github repository git/url]git push -u origin masternpm install hexo-deployer-git --savehexo g/generatehexo d/deploy 遇到的问题 ERROR Deployer not found: git 未执行 npm install hexo-deployer-git –save 命令 页面不能正常显示，或者404 我折腾了一下午，原因是：我随便取得名字。 无法执行 hexo 命令 运行 hexo init [project] 后，未执行：cd [project]。 页面404，收到GitHub发的邮件，内容如下： The tag fancybox on line 77 in themes/landscape/README.md is not a recognized Liquid tag. For more information, see https://help.github.com/en/articles/page-build-failed-unknown-tag-error. 解决方案，see hexo github #2590]]></content>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch入门篇——基础知识]]></title>
    <url>%2F2019%2F02%2F26%2FElasticsearch%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[还记得大二的时候，初入Java大门，就大言不惭的给老师说，我要开发一个搜索引擎，结果是各种学习，各种找资料，终于在期末的时候，做出了一个简单新闻搜索页面，搜索模块是使用了Lucene。 今天，我们一起走进Elasticsearch的殿堂。 Elastic以Elastic之名进行交易的数据搜索软件初创公司Elastic search于2018年10月5日（美国时间）上市。 Elastic Search 只是 Elastic 公司最出名的产品之一，其中还包括有分布式日志解决方案 ELK（Elastic Search、Logstash、Kibana）、Beats、ECE等。 Elasticsearch官网：https://www.elastic.co/cn/products/elasticsearch Elasticsearch is a distributed, RESTful search and analytics engine capable of solving a growing number of use cases. As the heart of the Elastic Stack, it centrally stores your data so you can discover the expected and uncover the unexpected. 翻译： Elasticsearch 是一个分布式的基于 RESTful 接口的搜索和分析引擎，它能够解决越来越多的使用场景。作为 Elastic Stack 的核心，它集中存储数据，可以发现预期及之外的结果。 Elastic Stack 的核心Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。 Elastic Stack 的特点：查询 保持好奇心。从数据中探寻各种问题的答案。 通过 Elasticsearch，您能够执行及合并多种类型的搜索（结构化数据、非结构化数据、地理位置、指标），搜索方式随心而变。先从一个简单的问题出发，试试看能够从中发现些什么。 分析 大处着眼，全局在握。 找到与查询最匹配的十个文档是一回事。但如果面对的是十亿行日志，又该如何解读呢？Elasticsearch 聚合让您能够从大处着眼，探索数据的趋势和模式。 速度 Elasticsearch 很快。 快到不可思议。 如果您能够立即获得答案，您与数据的关系就会发生变化。这样您就有条件进行迭代并涵盖更大的范围。 但是要达到这样的速度并非易事。我们通过有限状态转换器实现了用于全文检索的倒排索引，实现了用于存储数值数据和地理位置数据的 BKD 树，以及用于分析的列存储。 而且由于每个数据都被编入了索引，因此您再也不用因为某些数据没有索引而烦心。您可以用快到令人惊叹的速度使用和访问您的所有数据。 可扩展性 可以在笔记本电脑上运行。 也可以在承载了 PB 级数据的成百上千台服务器上运行。 原型环境和生产环境可无缝切换；无论 Elasticsearch 是在一个节点上运行，还是在一个包含 300 个节点的集群上运行，您都能够以相同的方式与 Elasticsearch 进行通信。 它能够水平扩展，每秒钟可处理海量事件，同时能够自动管理索引和查询在集群中的分布方式，以实现极其流畅的操作。 弹性 我们在您高飞的时候保驾护航。 硬件故障。网络分割。Elasticsearch 为您检测这些故障并确保您的集群（和数据）的安全性和可用性。通过跨集群复制功能，辅助集群可以作为热备份随时投入使用。 Elasticsearch 运行在一个分布式的环境中，从设计之初就考虑到了这一点，目的只有一个，让您永远高枕无忧。 灵活性 具备多个案例场景？一个全有。 数字、文本、地理位置、结构化数据、非结构化数据。欢迎使用所有数据类型。 应用搜索、安全分析、指标或日志分析只是全球众多公司利用 Elasticsearch 解决各种挑战的冰山一角。 操作的乐趣 享受更多成功的时刻，告别垂头丧气的失落 简单的事情就该简单做。我们确保 Elasticsearch 在任何规模下都能够易于操作，而无需在功能和性能方面做出牺牲。 客户端库 使用您自己的编程语言与 Elasticsearch 进行交互 Elasticsearch 使用的是标准的 RESTful 风格的 API 和 JSON。此外，我们还构建和维护了很多其他语言的客户端，例如 Java、Python、.NET、SQL 和 PHP。与此同时，我们的社区也贡献了很多客户端。这些客户端使用起来简单自然，而且就像 Elasticsearch 一样，不会对您的使用方式进行限制。 尽享强大功能 延展 Elasticsearch 为您的集群添加用户名和密码，监控 Elasticsearch 的性能表现，通过运行 Machine Learning 任务来发现异常等等，这些特性尽在 Elastic Stack 内置的多项功能。 通过 Security、Monitoring、Alerting、Reporting、Graph 关联分析和 Machine Learning 等功能，获得更优的使用体验。 HADOOP 和 SPARK Elasticsearch 加 Hadoop Hadoop 中有大量数据？您可以使用 Elasticsearch-Hadoop (ES-Hadoop)连接器，利用 Elasticsearch 的实时搜索和分析功能处理您的大数据。这是两大领域最大优势的融合。 基础概念我可以这样说，学习完这些概念，你或许就能明白RESTful的含义了，所以，学习这些概念是很有必要的。 Near Realtime (NRT) Elasticsearch is a near-realtime search platform. What this means is there is a slight latency (normally one second) from the time you index a document until the time it becomes searchable. 集群（Cluster） A cluster is a collection of one or more nodes (servers) that together holds your entire data and provides federated indexing and search capabilities across all nodes. A cluster is identified by a unique name which by default is “elasticsearch”. This name is important because a node can only be part of a cluster if the node is set up to join the cluster by its name. Make sure that you don’t reuse the same cluster names in different environments, otherwise you might end up with nodes joining the wrong cluster. For instance you could use logging-dev, logging-stage, and logging-prod for the development, staging, and production clusters. Note that it is valid and perfectly fine to have a cluster with only a single node in it. Furthermore, you may also have multiple independent clusters each with its own unique cluster name. 节点（Node） A node is a single server that is part of your cluster, stores your data, and participates in the cluster’s indexing and search capabilities. Just like a cluster, a node is identified by a name which by default is a random Universally Unique IDentifier (UUID) that is assigned to the node at startup. You can define any node name you want if you do not want the default. This name is important for administration purposes where you want to identify which servers in your network correspond to which nodes in your Elasticsearch cluster. A node can be configured to join a specific cluster by the cluster name. By default, each node is set up to join a cluster named elasticsearch which means that if you start up a number of nodes on your network and—assuming they can discover each other—they will all automatically form and join a single cluster named elasticsearch. In a single cluster, you can have as many nodes as you want. Furthermore, if there are no other Elasticsearch nodes currently running on your network, starting a single node will by default form a new single-node cluster named elasticsearch. 索引（Index） An index is a collection of documents that have somewhat similar characteristics. For example, you can have an index for customer data, another index for a product catalog, and yet another index for order data. An index is identified by a name (that must be all lowercase) and this name is used to refer to the index when performing indexing, search, update, and delete operations against the documents in it. In a single cluster, you can define as many indexes as you want. 类型（Type） A type used to be a logical category/partition of your index to allow you to store different types of documents in the same index, e.g. one type for users, another type for blog posts. It is no longer possible to create multiple types in an index, and the whole concept of types will be removed in a later version. See Removal of mapping types for more. 文档（Document） A document is a basic unit of information that can be indexed. For example, you can have a document for a single customer, another document for a single product, and yet another for a single order. This document is expressed in JSON (JavaScript Object Notation) which is a ubiquitous internet data interchange format. Within an index/type, you can store as many documents as you want. Note that although a document physically resides in an index, a document actually must be indexed/assigned to a type inside an index. Shards &amp; Replicas An index can potentially store a large amount of data that can exceed the hardware limits of a single node. For example, a single index of a billion documents taking up 1TB of disk space may not fit on the disk of a single node or may be too slow to serve search requests from a single node alone. To solve this problem, Elasticsearch provides the ability to subdivide your index into multiple pieces called shards. When you create an index, you can simply define the number of shards that you want. Each shard is in itself a fully-functional and independent “index” that can be hosted on any node in the cluster. Sharding is important for two primary reasons: It allows you to horizontally split/scale your content volume It allows you to distribute and parallelize operations across shards (potentially on multiple nodes) thus increasing performance/throughput The mechanics of how a shard is distributed and also how its documents are aggregated back into search requests are completely managed by Elasticsearch and is transparent to you as the user. In a network/cloud environment where failures can be expected anytime, it is very useful and highly recommended to have a failover mechanism in case a shard/node somehow goes offline or disappears for whatever reason. To this end, Elasticsearch allows you to make one or more copies of your index’s shards into what are called replica shards, or replicas for short. Replication is important for two primary reasons: It provides high availability in case a shard/node fails. For this reason, it is important to note that a replica shard is never allocated on the same node as the original/primary shard that it was copied from. It allows you to scale out your search volume/throughput since searches can be executed on all replicas in parallel. To summarize, each index can be split into multiple shards. An index can also be replicated zero (meaning no replicas) or more times. Once replicated, each index will have primary shards (the original shards that were replicated from) and replica shards (the copies of the primary shards). The number of shards and replicas can be defined per index at the time the index is created. After the index is created, you may also change the number of replicas dynamically anytime. You can change the number of shards for an existing index using the _shrink and _split APIs, however this is not a trivial task and pre-planning for the correct number of shards is the optimal approach. By default, each index in Elasticsearch is allocated 5 primary shards and 1 replica which means that if you have at least two nodes in your cluster, your index will have 5 primary shards and another 5 replica shards (1 complete replica) for a total of 10 shards per index. 结构 上图来自SpringBoot整合ElasticSearch及源码 安装配置： 1234567891011cluster.name: es-wyfnode.name: masterpath.data: /Users/wenyifeng/Software/elasticsearch/data/master/datapath.logs: /Users/wenyifeng/Software/elasticsearch/data/master/logsnetwork.host: 127.0.0.1http.port: 9200discovery.zen.ping.unicast.hosts: ["127.0.0.1"]http.cors.enabled: truehttp.cors.allow-origin: "*"bootstrap.memory_lock: falsebootstrap.system_call_filter: false 说起配置，我是很头疼的，看过视频教程和很多博文，都失败，最后在老大的帮助下，成功了，给了我如上配置。感谢我们老大对我的帮助。 Mac 安装12#下载并解压，进入目录，后台运行./bin/elasticsearch -d docker安装 Pulling the imageObtaining Elasticsearch for Docker is as simple as issuing a docker pull command against the Elastic Docker registry. 12&gt; docker pull docker.elastic.co/elasticsearch/elasticsearch:6.6.1&gt; Alternatively, you can download other Docker images that contain only features available under the Apache 2.0 license. To download the images, go to www.docker.elastic.co. Running Elasticsearch from the command lineDevelopment modeeditElasticsearch can be quickly started for development or testing use with the following command: 12&gt; docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:6.6.1&gt; 官网教程：https://www.elastic.co/guide/en/elasticsearch/reference/6.6/docker.html#docker-cli-run-dev-mode CentOS安装这个问题，问下运维的同学吧。 ElasticSearch Head服务器安装地址：https://github.com/mobz/elasticsearch-head 从git上下下来，解压并进入，运行如下命令： 12npm installnpm run start 浏览器插件搜索 ElasticSearch Head 创建索引假设我们创建一个学校，有一个初2一班，学生的属性有：学号、姓名、年龄。 PUT http://localhost:9200/school 1234567891011121314151617&#123; "mappings":&#123; "c2_1": &#123; "properties":&#123; "no":&#123; "type":"keyword" &#125;, "name":&#123; "type":"text" &#125;, "age":&#123; "type":"integer" &#125; &#125; &#125; &#125;&#125; 返回: 12345&#123; "acknowledged": true, "shards_acknowledged": true, "index": "school"&#125; 这样就表示索引创建成功。 基本操作CRUD增加我们向里面插入一条数据，例如学号201901，姓名张三，年龄20。 POST http://localhost:9200/school/c2_1 12345&#123; "no":"201901", "name":"张三", "age":20&#125; 返回： 1234567891011121314&#123; "_index": "school", "_type": "c2_1", "_id": "8ygbK2kBenMJLC7I-EaK", "_version": 1, "result": "created", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 0, "_primary_term": 1&#125; 查询我们通过返回的id查询一下: GET http://localhost:9200/school/c2_1/8ygbK2kBenMJLC7I-EaK 返回： 1234567891011121314&#123; "_index": "school", "_type": "c2_1", "_id": "8ygbK2kBenMJLC7I-EaK", "_version": 1, "_seq_no": 0, "_primary_term": 1, "found": true, "_source": &#123; "no": "201901", "name": "张三", "age": 20 &#125;&#125; 查询出来了，这说明我们的增加和查询操作都成功了。 修改我们把张三的年龄修改为22. PUT http://localhost:9200/school/c2_1/8ygbK2kBenMJLC7I-EaK 12345&#123; "no":"201901", "name":"张三", "age":22&#125; 返回： 1234567891011121314&#123; "_index": "school", "_type": "c2_1", "_id": "8ygbK2kBenMJLC7I-EaK", "_version": 2, "result": "updated", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 1, "_primary_term": 1&#125; 查询一下： 与预期一致。 删除我们根据ID删除数据 DELETE http://localhost:9200/school/c2_1/8ygbK2kBenMJLC7I-EaK 返回： 1234567891011121314&#123; "_index": "school", "_type": "c2_1", "_id": "8ygbK2kBenMJLC7I-EaK", "_version": 3, "result": "deleted", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 2, "_primary_term": 1&#125; 再查询就没有，如下返回： 123456&#123; "_index": "school", "_type": "c2_1", "_id": "8ygbK2kBenMJLC7I-EaK", "found": false&#125; 删除索引删除索引之后，索引下面的索引文档都将被删除。 DELETE http://localhost:9200/school 返回： 123&#123; "acknowledged": true&#125; 高级查询接口通用查询API接口：http://localhost:9200/book/_search 提交方式，可以是GET，也可以是POST（JSON）。 构造数据我们首先构造数据，如下 Query ContextQuery Context：在查询过程中，除了判断文档是否满足查询条件外，Elasticsearch还会计算一个 _score 来标识匹配的程度，旨在判断目标文档和查询条件匹配的 有多好。简单来说就是，匹配到了吗？有多吻合呢? 常用查询全文本搜索：针对文本类型的数据 字段级别查询：针对结构化数据，如数字、日期等 全文本匹配搜索： 1234567&#123; "query":&#123; "match":&#123; "author":"明日科技" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728&#123; "took": 4, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.9808292, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 0.9808292, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125; ] &#125;&#125; 这是模糊匹配，先进行分词，然后会把相关的都会查询出来，如下： 搜索： 1234567&#123; "query":&#123; "match":&#123; "title":"elasticsearch入门" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; "took": 4, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 4, "max_score": 0.3252806, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "FNW0L2kBvvhXwNB9pJ0W", "_score": 0.3252806, "_source": &#123; "title": "Python编程 从入门到实践", "author": "[美]埃里克·马瑟斯（Eric Matthes）", "word_count": 10010, "publish_date": "2016-07-10" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 0.28924954, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "EtWxL2kBvvhXwNB93p1F", "_score": 0.2876821, "_source": &#123; "title": "Elasticsearch实战", "author": "[美] 拉杜·乔戈（Radu Gheorghe） 马修·李·欣曼（Matthew", "word_count": 10005, "publish_date": "2018-10-2" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "E9WzL2kBvvhXwNB9MZ3I", "_score": 0.21268348, "_source": &#123; "title": "Laravel入门与实战 构建主流PHP应用开发框架 Laravel开发框架教程书籍 ", "author": "拉杜 乔戈", "word_count": 10007, "publish_date": "2017-11-03" &#125; &#125; ] &#125;&#125; 这里将 elasticsearch入门 分解为 elasticsearch 和 入门。 match_phrase如果我们并不想那样进行分割，那我们换一个关键字 match_phrase 搜索： 1234567&#123; "query":&#123; "match_phrase":&#123; "title":"elasticsearch入门" &#125; &#125;&#125; 结果： 123456789101112131415&#123; "took": 3, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 0, "max_score": null, "hits": [] &#125;&#125; 就什么也没有了。 我们再搜索： 1234567&#123; "query":&#123; "match_phrase":&#123; "title":"elasticsearch" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728&#123; "took": 3, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.2876821, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "EtWxL2kBvvhXwNB93p1F", "_score": 0.2876821, "_source": &#123; "title": "Elasticsearch实战", "author": "[美] 拉杜·乔戈（Radu Gheorghe） 马修·李·欣曼（Matthew", "word_count": 10005, "publish_date": "2018-10-2" &#125; &#125; ] &#125;&#125; 我们再换关键字： 1234567&#123; "query":&#123; "match_phrase":&#123; "title":"入门" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; "took": 11, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 0.3252806, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "FNW0L2kBvvhXwNB9pJ0W", "_score": 0.3252806, "_source": &#123; "title": "Python编程 从入门到实践", "author": "[美]埃里克·马瑟斯（Eric Matthes）", "word_count": 10010, "publish_date": "2016-07-10" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 0.28924954, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "E9WzL2kBvvhXwNB9MZ3I", "_score": 0.21268348, "_source": &#123; "title": "Laravel入门与实战 构建主流PHP应用开发框架 Laravel开发框架教程书籍 ", "author": "拉杜 乔戈", "word_count": 10007, "publish_date": "2017-11-03" &#125; &#125; ] &#125;&#125; 多个字段查询搜索： 12345678&#123; "query":&#123; "multi_match":&#123; "query":"java", "fields":["title", "author"] &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728&#123; &quot;took&quot;: 2, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 1, &quot;max_score&quot;: 1.0623134, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;book&quot;, &quot;_type&quot;: &quot;it&quot;, &quot;_id&quot;: &quot;EdWwL2kBvvhXwNB9h50h&quot;, &quot;_score&quot;: 1.0623134, &quot;_source&quot;: &#123; &quot;title&quot;: &quot;Java从入门到精通（第4版）（附光盘）&quot;, &quot;author&quot;: &quot;明日科技&quot;, &quot;word_count&quot;: 10002, &quot;publish_date&quot;: &quot;2016-09-01&quot; &#125; &#125; ] &#125;&#125; 语法查询搜索： 1234567&#123; "query":&#123; "query_string":&#123; "query":"java" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728&#123; "took": 6, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1.0623134, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 1.0623134, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125; ] &#125;&#125; 搜索： 1234567&#123; "query":&#123; "query_string":&#123; "query":"java and 入门" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; "took": 3, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1.351563, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 1.351563, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "FNW0L2kBvvhXwNB9pJ0W", "_score": 0.3252806, "_source": &#123; "title": "Python编程 从入门到实践", "author": "[美]埃里克·马瑟斯（Eric Matthes）", "word_count": 10010, "publish_date": "2016-07-10" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "E9WzL2kBvvhXwNB9MZ3I", "_score": 0.21268348, "_source": &#123; "title": "Laravel入门与实战 构建主流PHP应用开发框架 Laravel开发框架教程书籍 ", "author": "拉杜 乔戈", "word_count": 10007, "publish_date": "2017-11-03" &#125; &#125; ] &#125;&#125; 这个给我的个人感觉不好玩，就小小的尝试一下吧。 字段级别的查询搜索： 1234567&#123; "query":&#123; "term":&#123; "word_count":"100" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728&#123; "took": 14, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "FdW1L2kBvvhXwNB91Z2M", "_score": 1, "_source": &#123; "title": "数据结构（C语言版）", "author": "严蔚敏", "word_count": 100, "publish_date": "2007-03-09" &#125; &#125; ] &#125;&#125; term：用于查询特定值 范围查询例如，我们搜索大于10000个字的书： 123456789&#123; "query":&#123; "range":&#123; "word_count":&#123; "gte":10000 &#125; &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; "took": 5, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 4, "max_score": 1, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "EtWxL2kBvvhXwNB93p1F", "_score": 1, "_source": &#123; "title": "Elasticsearch实战", "author": "[美] 拉杜·乔戈（Radu Gheorghe） 马修·李·欣曼（Matthew", "word_count": 10005, "publish_date": "2018-10-2" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 1, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "E9WzL2kBvvhXwNB9MZ3I", "_score": 1, "_source": &#123; "title": "Laravel入门与实战 构建主流PHP应用开发框架 Laravel开发框架教程书籍 ", "author": "拉杜 乔戈", "word_count": 10007, "publish_date": "2017-11-03" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "FNW0L2kBvvhXwNB9pJ0W", "_score": 1, "_source": &#123; "title": "Python编程 从入门到实践", "author": "[美]埃里克·马瑟斯（Eric Matthes）", "word_count": 10010, "publish_date": "2016-07-10" &#125; &#125; ] &#125;&#125; 时间也可以搜索范围，比如我们搜索 (2016-09-01, 2018-01-01) 这个时间段之间要出版书： 12345678910&#123; "query":&#123; "range":&#123; "publish_date":&#123; "gt":"2016-09-01", "lt":"2018-01-01" &#125; &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "E9WzL2kBvvhXwNB9MZ3I", "_score": 1, "_source": &#123; "title": "Laravel入门与实战 构建主流PHP应用开发框架 Laravel开发框架教程书籍 ", "author": "拉杜 乔戈", "word_count": 10007, "publish_date": "2017-11-03" &#125; &#125; ] &#125;&#125; 取等吧，[2016-09-01, 2018-01-01) ： 12345678910&#123; "query":&#123; "range":&#123; "publish_date":&#123; "gte":"2016-09-01", "lt":"2018-01-01" &#125; &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 2, "max_score": 1, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 1, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "E9WzL2kBvvhXwNB9MZ3I", "_score": 1, "_source": &#123; "title": "Laravel入门与实战 构建主流PHP应用开发框架 Laravel开发框架教程书籍 ", "author": "拉杜 乔戈", "word_count": 10007, "publish_date": "2017-11-03" &#125; &#125; ] &#125;&#125; 当前日期，可用关键字 now 关键字：filter在查询过程中，只判断文档是否满足条件，只有Yes或者No。 举个例子，我们要搜索字数是100的有哪些，搜索如下： 1234567891011&#123; "query":&#123; "bool":&#123; "filter":&#123; "term":&#123; "word_count":100 &#125; &#125; &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728&#123; "took": 40, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "FdW1L2kBvvhXwNB91Z2M", "_score": 0, "_source": &#123; "title": "数据结构（C语言版）", "author": "严蔚敏", "word_count": 100, "publish_date": "2007-03-09" &#125; &#125; ] &#125;&#125; 复杂查询固定分数查询：constant_score 12345678910111213&#123; "query":&#123; "constant_score":&#123; "filter":&#123; "match":&#123; "title":"ElasticSearch" &#125; &#125;, "boost":2 &#125; &#125;&#125; 不支持 match查询，支持filter查询。 布尔查询：bool搜索： 123456789101112131415161718&#123; "query": &#123; "bool": &#123; "should": [ &#123; "match": &#123; "author": "明日科技" &#125; &#125;, &#123; "match": &#123; "title": "ElasticSearch" &#125; &#125; ] &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940&#123; "took": 4, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 2, "max_score": 0.9808292, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 0.9808292, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "EtWxL2kBvvhXwNB93p1F", "_score": 0.2876821, "_source": &#123; "title": "Elasticsearch实战", "author": "[美] 拉杜·乔戈（Radu Gheorghe） 马修·李·欣曼（Matthew", "word_count": 10005, "publish_date": "2018-10-2" &#125; &#125; ] &#125;&#125; 是 OR 的关系 看一下 AND 关系： 123456789101112131415161718&#123; "query": &#123; "bool": &#123; "must": [ &#123; "match": &#123; "author": "明日科技" &#125; &#125;, &#123; "match": &#123; "title": "ElasticSearch" &#125; &#125; ] &#125; &#125;&#125; 结果： 123456789101112131415&#123; "took": 3, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 0, "max_score": null, "hits": [] &#125;&#125; 我们换一下关键字，搜索： 123456789101112131415161718&#123; "query": &#123; "bool": &#123; "must": [ &#123; "match": &#123; "author": "明日科技" &#125; &#125;, &#123; "match": &#123; "title": "java" &#125; &#125; ] &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728&#123; "took": 13, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 2.0431426, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 2.0431426, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125; ] &#125;&#125; 加拦截条件，我们查看字数是10000的： 12345678910111213141516171819202122232425&#123; "query": &#123; "bool": &#123; "must": [ &#123; "match": &#123; "author": "明日科技" &#125; &#125;, &#123; "match": &#123; "title": "java" &#125; &#125; ], "filter": [ &#123; "term": &#123; "word_count": 10000 &#125; &#125; ] &#125; &#125;&#125; 结果： 123456789101112131415&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 0, "max_score": null, "hits": [] &#125;&#125; 好吧，我们将word_count换成10002： 1234567891011121314151617181920212223&#123; "query": &#123; "bool": &#123; "must": [ &#123; "match": &#123; "author": "明日科技" &#125; &#125;, &#123; "match": &#123; "title": "java" &#125; &#125; ], "filter":[&#123; "term":&#123; "word_count":10002 &#125; &#125;] &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728&#123; "took": 3, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 2.0431426, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "EdWwL2kBvvhXwNB9h50h", "_score": 2.0431426, "_source": &#123; "title": "Java从入门到精通（第4版）（附光盘）", "author": "明日科技", "word_count": 10002, "publish_date": "2016-09-01" &#125; &#125; ] &#125;&#125; 关键字：must_not 例如，我不看java： 1234567891011&#123; "query":&#123; "bool":&#123; "must_not":&#123; "term":&#123; "title":"java" &#125; &#125; &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; "took": 5, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 4, "max_score": 1, "hits": [ &#123; "_index": "book", "_type": "it", "_id": "FdW1L2kBvvhXwNB91Z2M", "_score": 1, "_source": &#123; "title": "数据结构（C语言版）", "author": "严蔚敏", "word_count": 100, "publish_date": "2007-03-09" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "EtWxL2kBvvhXwNB93p1F", "_score": 1, "_source": &#123; "title": "Elasticsearch实战", "author": "[美] 拉杜·乔戈（Radu Gheorghe） 马修·李·欣曼（Matthew", "word_count": 10005, "publish_date": "2018-10-2" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "E9WzL2kBvvhXwNB9MZ3I", "_score": 1, "_source": &#123; "title": "Laravel入门与实战 构建主流PHP应用开发框架 Laravel开发框架教程书籍 ", "author": "拉杜 乔戈", "word_count": 10007, "publish_date": "2017-11-03" &#125; &#125;, &#123; "_index": "book", "_type": "it", "_id": "FNW0L2kBvvhXwNB9pJ0W", "_score": 1, "_source": &#123; "title": "Python编程 从入门到实践", "author": "[美]埃里克·马瑟斯（Eric Matthes）", "word_count": 10010, "publish_date": "2016-07-10" &#125; &#125; ] &#125;&#125; 关于搜索，这只是入门，我们会在第三节会继续讨论搜索。 链接 ElasticSearch入门 Elastic官网 ElasticSearch ElasticSearch Docs ElasticSearch Head 搜索软件Elastic上市：市值近50亿美元 是开源项目商业化范本 ElasticSearch 学习系列 Elasticsearch入门篇——基础知识 Elasticsearch实战篇——Spring Boot整合ElasticSearch Elasticsearch专题篇——搜索]]></content>
  </entry>
</search>
